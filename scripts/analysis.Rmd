---
title: "Calculating PDSI and SPEI"
author: "steppe"
output:
  word_document: default
always_allow_html: true
---

Variables required:

Precipitation
Available Water Content

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
knitr::opts_chunk$set(dpi = 300) 
knitr::opts_chunk$set(message = F)
knitr::opts_chunk$set(warning = F)
```

```{r}
library(tidyverse)
library(terra)
source('functions.R')
```


Create potential solar hours rasters

"Elevation, aspect and slope input values should not be reclassified into coarser categories. This could lead to incorrect results. " - r.sun man pages

```{r Create template raster for sun hours, eval = F}

template <- rast('/hdd/Geospatial_data/sunhours/input/UFO_dem_10_smooth.tif')
xy <- ext(template)

coarse_template <- rast(nrow = 100, ncol = 100, crs = crs(template),
     xmin = xy[1], xmax =	 xy[2], ymin 	=  xy[3], ymax =  xy[4], vals = 0
       )
writeRaster(coarse_template, '/hdd/Geospatial_data/sunhours/input/coarse.tif')

rm(template, xy, coarse_template)
```


To calculate Sun hours the r.sun function from GRASS GIS was used to calculate the sun hours for across the field office for the year 2010.
```{bash calculate sun hours in GRASS GIS, eval = F}

grass --tmp-location /hdd/Geospatial_data/sunhours/input/coarse.tif
pOUT='/hdd/Geospatial_data/sunhours/output'

for i in {1..365}
do
  rasterfari=SunHours$i
  r.sunhours sunhour=$rasterfari year=2000 day=$i --overwrite
  r.out.gdal input=$rasterfari output=$pOUT/${rasterfari} format=GTiff -c --overwrite
done

r.in.gdal input=/hdd/Geospatial_data/sunhours/input/coarse.tif output=coarseDEM

for i in {1..365}
do
  rasterfari=BeamRad$i
  r.sun beam_rad=$rasterfari day=$i --overwrite nprocs=16 elevation=coarseDEM linke_value=2.325
  r.out.gdal input=$rasterfari output=$pOUT/${rasterfari} format=GTiff -c --overwrite
done

exit

```

The means of each month was taken and used as sun values across the entirety of the temporal domain.
```{r Process Sun Hour Data into Monthly Means, eval =F}

sh_p <- '/hdd/Geospatial_data/sunhours/output'

files <- data.frame(filename = list.files(sh_p, pattern = 'SunHours')) %>% 
  mutate(number = as.numeric(str_extract_all(filename,"\\(?[0-9,.]+\\)?")),
         fpath = file.path(sh_p, filename)) %>% 
  arrange(number) %>% 
  bind_cols(., 'Month' =  dmonths_normal)

mean_rasters <- files %>% 
  split(., .$Month) %>% 
  lapply(., '[[', c('fpath')) %>% 
  map(., rast) %>% 
  map(., mean)
mean_rasters <- rast(mean_rasters)

writeRaster(mean_rasters, '../data/raw/MeanSunHours.tif', overwrite = T)
file.remove(files$fpath)

# repeat the process for solar radiation. 
files <- data.frame(filename = list.files(sh_p, pattern = 'BeamRad')) %>% 
  mutate(number = as.numeric(str_extract_all(filename,"\\(?[0-9,.]+\\)?")),
         fpath = file.path(sh_p, filename)) %>% 
  arrange(number) %>% 
  bind_cols(., 'Month' =  dmonths_normal)

mean_rasters <- files %>% 
  split(., .$Month) %>% 
  lapply(., '[[', c('fpath')) %>% 
  map(., rast) %>% 
  map(., mean)
mean_rasters <- rast(mean_rasters)
mean_rasters <- mean_rasters * 0.0036 # conversion to MegaJoules, you can 
# compare your values to a kilowatt / hour map to see if you are in the range
# before you do this just do mean( mean_raster/1000 ) and is is really
# quick to find an annual map, I recommend doing it to make sure your calcs worked
# out A-OK - this stuff is way outside my wheelhouse. Ours are spot on. 

writeRaster(mean_rasters, '../data/raw/MeanRadiation.tif', overwrite = T)
file.remove(files$fpath)

rm(pancake, dmonths, sh_p, files, mean_rasters)
```

```{r Download climate vars from gridmet and subset, eval = F}

p <- '/media/reed/ExternalHD/drought_geospatial/Gridmet'
Get_Gridmet(product_type = "pr", start_year = 1979, end_year = 2021, destination = p)
Get_Gridmet(product_type = "tmmx", start_year = 1979, end_year = 2021, destination = p)
Get_Gridmet(product_type = "tmmn", start_year = 1979, end_year = 2021, destination = p)
Get_Gridmet(product_type = "vs", start_year = 1979, end_year = 2021, destination = p)
Get_Gridmet(product_type = "rmax", start_year = 1979, end_year = 2021, destination = p)
Get_Gridmet(product_type = "rmin", start_year = 1979, end_year = 2021, destination = p)
p <- file.path(p, 'Gridmet')

```


```{r reduce gridmet climate vars to monthly means, eval = F}
# now reduce the size of these data by making the monthly means
root_p <- '/media/reed/ExternalHD/drought_geospatial/Gridmet'
out_p <- '/media/reed/ExternalHD/drought_geospatial/monthly_gridmet'
crop_p <- '../data/raw/UFO_slope_deg.tif'

gridSTATS(inpath = root_p , FUN = mean,  outpath = out_p, cropRast = crop_p, variable = 'vs')
gridSTATSsum(inpath = root_p , outpath = out_p, cropRast = crop_p, variable = 'pr')
gridSTATS(inpath = root_p , FUN = mean,  outpath = out_p, cropRast = crop_p, variable = 'tmmn')
gridSTATS(inpath = root_p , FUN = mean,  outpath = out_p, cropRast = crop_p, variable = 'tmmx')
gridSTATS(inpath = root_p , FUN = mean,  outpath = out_p, cropRast = crop_p, variable = 'rmax')
gridSTATS(inpath = root_p , FUN = mean,  outpath = out_p, cropRast = crop_p, variable = 'rmin')

rmax <- rast(file.path(out_p, 'rmin', (list.files(file.path(out_p, 'rmin')))))
rmin <- rast(file.path(out_p, 'rmax', (list.files(file.path(out_p, 'rmax')))))
rhmean <- mean(rmax, rmin)
rhmean <- split(rhmean, leapYearLookUp$Year)
names(rhmean) <- unique(leapYearLookUp$Year)

ifelse(!dir.exists(file.path(out_p, 'rhmean')), 
         dir.create(file.path(out_p, 'rhmean')), FALSE)
fnames <- file.path(out_p, 'rhmean', paste0('rhmean', '_', names(rhmean), '.tif'))
mapply(writeRaster, rhmean, fnames, overwrite =T)

rm(root_p, out_p, crop_p, gridSTATS)
```

```{r Border}
border <- ext(rast('../data/raw/UFO_slope_deg.tif'))
```

```{r Crop Cloud data, eval = F}

cpath <- '/media/reed/ExternalHD/drought_geospatial/cloud'
cfiles <- file.path(cpath, list.files(cpath, pattern = "tif$"))
clouds <- rast(cfiles)

border <- project(rast('../data/raw/UFO_slope_deg.tif'), crs(clouds))
clouds <- crop(clouds, border)
template <- rast('/media/reed/ExternalHD/drought_geospatial/monthly_gridmet/vs/vs_1979.tif')[[1]]
clouds <- aggregate(clouds, fact =4)
clouds <- resample(clouds, template, method  = 'cubic')
names(clouds) <- unique(dmonths_normal)

# 0.01 the clouds values range from 0-10,000, and need be multiplied by 0.01 to recover % cover
clouds <- clouds * 0.01
plot(clouds)

writeRaster(clouds, '../data/raw/clouds.tif', NAflag=NA, overwrite = T)
rm(cpath, clouds, border, cfiles)
```


```{r subtract clouds from sun hours, eval = F}
SunHours <- rast('/media/reed/ExternalHD/UFO_drought/data/raw/MeanSunHours.tif')
SunHours <- resample(SunHours, template, method  = 'cubic')
SunHours <- SunHours[[unique(dmonths_normal)]]
SunHours <- project(SunHours, crs(template))

cloud_rasters <- 1 - (rast('../data/raw/clouds.tif') * 0.01 )  # to get a leading zero for a proportion
SunHours <- SunHours * cloud_rasters

writeRaster(SunHours, '../data/raw/MeanSunHours.tif',
            overwrite = T)
rm(SunHours)
```


```{r Process and match extent for total solar radiation, eval = F}
solar_radiation <- rast('../data/raw/MeanRadiation.tif')
solar_radiation <- resample(solar_radiation, template, method  = 'cubic')
solar_radiation <- solar_radiation[[unique(dmonths_normal)]]
solar_radiation <- project(solar_radiation, crs(template))

writeRaster(solar_radiation, '../data/raw/MeanSolarRadiation.tif',
            overwrite = T)
rm(solar_radiation)
```


```{r Crop DEM, eval = F}

dpath <- '/media/reed/ExternalHD/drought_geospatial/dem'
dem <- rast(file.path(dpath, list.files(dpath, pattern = "bil$", recursive = T)))

border <- project(rast('../data/raw/UFO_slope_deg.tif'), crs(dem))
dem <- crop(dem, border)

template <- rast('/media/reed/ExternalHD/drought_geospatial/monthly_gridmet/vs/vs_1979.tif')[[1]]
dem <- resample(dem, template, method  = 'cubic')
dem <- exactextractr::exact_resample(dem, template, "mean")

writeRaster(dem, '../data/raw/dem.tif', overwrite = T)
rm(dpath, dem, template)
```

```{r Calculate SPEI}
syear <- 1979
eyear <- 2021
out_p <- '/media/reed/ExternalHD/drought_geospatial/monthly_gridmet'
template <- rast('/media/reed/ExternalHD/drought_geospatial/monthly_gridmet/vs/vs_1979.tif')[[1]]

cloudCover <- rast('../data/raw/clouds.tif')
sunHours <- rast('../data/raw/MeanSunHours.tif')
dem <- rast('../data/raw/dem.tif')
solarRadiation <- rast('../data/raw/MeanSolarRadiation.tif')

vs <- rast(file.path(out_p, 'vs', (list.files(file.path(out_p, 'vs')))))
tmax <- rast(file.path(out_p, 'tmmx', (list.files(file.path(out_p, 'tmmx')))))
tmin <- rast(file.path(out_p, 'tmmn', (list.files(file.path(out_p, 'tmmn')))))
pr <- rast(file.path(out_p, 'pr', (list.files(file.path(out_p, 'pr'))))) # rhmean.tif
rh <- rast(file.path(out_p, 'rhmean', (list.files(file.path(out_p, 'rhmean')))))

names(vs) <- namer(vs, start = syear, end = eyear)
names(tmax) <- namer(tmax, start = syear)
names(tmin) <- namer(tmin, start = syear)
names(pr) <- namer(pr, start = syear)
names(rh) <- namer(rh, start = syear)
names(dem) <- 'elevation'
variables <- c(vs, tmax, tmin, rh, pr, dem)

names(cloudCover) <- paste0('cloudcover_', unique(dmonths_normal))
names(sunHours) <- paste0('sunhours_', names(sunHours))
names(solarRadiation) <- paste0('radiation_', names(solarRadiation))
suncloud <- c(cloudCover, sunHours, solarRadiation)

cloudvals <- as.data.frame(suncloud) %>% 
  rownames_to_column('CellID') %>% 
  pivot_longer(!CellID, names_to = 'combo', values_to = 'value') %>% 
  separate(combo, c('variable', 'month')) %>% 
  pivot_wider(names_from = variable, values_from = value)
drought_vars <- as.data.frame(variables, xy = T) %>% 
  rownames_to_column('CellID') %>% 
  pivot_longer(4:(ncol(.)-1)) %>% 
  separate(name, c('variable', 'month', 'year')) %>% 
  pivot_wider( names_from = variable, values_from = value) %>% 
  left_join(., cloudvals) %>% 
  mutate(across(.cols = tmax:tmin, ~.x - 273.5 ))

rm(cloudvals, suncloud, vs, tmax, tmin, variables, dem, pr, sunHours, rh, 
   solarRadiation, cloud_rasters)

myscales <- c(6,12,24)
# drought_vars <- drought_vars[complete.cases(drought_vars),]
out <- drought_vars %>% 
  rowwise() %>% 
  split(., .$CellID) %>% 
  map(~ PeTbyCell(x = .x)) %>% 
  bind_rows() %>% 
  arrange(CellID, year) %>% 
  split(., .$CellID) %>% 
  map(~ SPEIbyCell(x = .x, start_yr = syear, id_var = 'CellID', scales = myscales)) %>% 
  bind_rows()

# now we will split these out so that each year x calculation duration has a stack. 
resin <- out %>% 
  pivot_longer(cols = starts_with('months'), names_to = 'period', values_to = 'SPEI') %>% 
  split(., .[,c('period','Year', 'Month')]) %>% 
  map(~ rast(template, vals = .x$SPEI))

vars <- c('months_6', 'months_12', 'months_24')
times <- leapYearLookUp %>% 
  mutate(time = paste0(Year, '.', MONTH)) %>% 
  pull(time)
vars2 <- paste0(rep(vars, each =  length(times)), '.', times)
names(resin) <- vars2
splits <- data.frame(raw = vars2) %>% 
  separate(raw, into = c('period', 'year', 'month'), sep = '[.]')

resin <- resin[vars2]
resin <- split(resin, splits$period)
resin <- lapply(resin, rast)

focal_window <- 9
resin <- lapply(resin, focal, w = focal_window, na.policy="only",  na.rm=TRUE, fun = mean)

outpath <- '../data/processed'
variable <- 'SPEI'
ifelse(!dir.exists(file.path(outpath)), 
       dir.create(file.path(outpath)), FALSE)
ifelse(!dir.exists(file.path(outpath, variable)), 
       dir.create(file.path(outpath, variable)), FALSE)
fnames <- file.path(outpath, variable, paste0(variable, '_', names(resin), '.tif'))
mapply(writeRaster, resin, fnames, overwrite = T)

rm(tmax, tmin, vs, variables, cloudCover, cloudvals, dem, sunHours, suncloud, 
   SunHours, pr, out_p, outpath, variable, resin , splits, vars2, vars, out, 
   fnames, times, drought_vars)
```

SPEI was calculated for all `r toString(eyear-syear)` years between `r toString(syear)`-`r toString(eyear)`. Cells in rasters which contained missing (NA) values, these resulting from missing a value required for either the penman or SPEI calculations, were filled using the 'focal' function from the r package 'Terra'. This function calculated the mean of the `r toString(focal_window)`. SPEI was calculated using moisture balances of the: `r toString(myscales)` months preceding the current month of analysis. For example, the SPEI value for the Month of January 1981, under a scenario with a 6 month window, would go back as far as June 1980, while for a longer window such as 24 months, would go back to January 1979. Because our SPEI calculations included these windows, each data set could not-natively start at the same date. For example our dataset with the longest SPEI window, `r toString(max(myscales))` months, exceeded the shortest windows by `r toString(max(myscales) - min(myscales))`. Accordingly, we removed any months of values preceding the origin date for the start of the longest SPEI calculation intervals, and for ease of analysis and reporting began our background climate dataset in `r toString(syear + max(myscales)/12)`.

```{r, eval = F}
rm(leapYearLookUp, dmonths_leap, dmonths_normal, path, fchoice, gridSTATSsum, 
   namer, PeTbyCell, SPEIbyCell)
rm(syear, eyear, focal_window, myscales)
```


We subset the drought data so that the beginning period for all temporal extents has the same start date, January 1981. It is recommended to have 30 years of climate data to compare local conditions to. We will span the years from 1981-2015 as our `r 2015-1981` year background data. This will also allow a slight degree of buffering between our data sets, so that the starting times between our two datasets, the occurrence of drought during the AIM sampling, and the historic climate variables are not temporally replicated. 

```{r}
fp <- '../data/processed/SPEI'
m6 <- rast(file.path(fp, 'SPEI_months_6.tif'))


d <- values(m6)
d <- d[, !colSums(is.na(d)), drop = FALSE]
d <- apply(d, MARGIN = 2, mean)
d <- data.frame(time=names(d), SPEI=d, row.names=NULL) %>%
  separate(time, into = c('period', 'year', 'month'), sep = '[.]') %>% 
  group_by(year) %>% 
  count()
  
#  mutate(time = str_remove(time, 'months_[0-9]\\.')) %>% 
  rowid_to_column()

ggplot(d, aes(x = rowid, y = SPEI)) +
  geom_line()

```

